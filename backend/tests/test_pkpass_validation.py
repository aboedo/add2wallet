"""
Comprehensive integration tests for validating Apple Wallet .pkpass files
generated by the Add2Wallet backend.

Validates ZIP structure, pass.json fields, manifest integrity, icon assets,
and barcode formats against the Apple Wallet PassKit specification.

Can also be run as a standalone CLI tool:
    python tests/test_pkpass_validation.py path/to/file.pkpass [...]
"""

import hashlib
import io
import json
import os
import re
import sys
import zipfile
from dataclasses import dataclass, field
from typing import Dict, List, Optional

import pytest

# Ensure backend is importable
sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from tests.conftest import TEST_FILES_DIR, TEST_PDFS


# ---------------------------------------------------------------------------
# PkpassValidator
# ---------------------------------------------------------------------------

VALID_PASS_TYPE_KEYS = {"generic", "eventTicket", "boardingPass", "coupon", "storeCard"}

VALID_BARCODE_FORMATS = {
    "PKBarcodeFormatQR",
    "PKBarcodeFormatPDF417",
    "PKBarcodeFormatAztec",
    "PKBarcodeFormatCode128",
}

RGB_PATTERN = re.compile(r"^rgb\(\s*\d{1,3}\s*,\s*\d{1,3}\s*,\s*\d{1,3}\s*\)$")

PNG_MAGIC = b"\x89PNG"

IOS26_KEYS = {"semantics", "upcomingPassInformation"}


@dataclass
class ValidationResult:
    is_valid: bool = True
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    pass_json: Optional[Dict] = None

    def add_error(self, msg: str) -> None:
        self.errors.append(msg)
        self.is_valid = False

    def add_warning(self, msg: str) -> None:
        self.warnings.append(msg)


class PkpassValidator:
    """Reusable validator for .pkpass files against Apple's PassKit spec."""

    def validate(self, pkpass_bytes: bytes) -> ValidationResult:
        result = ValidationResult()

        # 1. ZIP structure
        if not self._validate_zip(pkpass_bytes, result):
            return result

        with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
            names = zf.namelist()

            # Flat structure (no directories)
            for name in names:
                if "/" in name:
                    result.add_error(f"ZIP contains directory path: {name}. pkpass must be flat.")

            # 2. Required files
            self._validate_required_files(names, result)

            # 3. pass.json
            if "pass.json" in names:
                self._validate_pass_json(zf, result)

            # 4. manifest.json
            if "manifest.json" in names:
                self._validate_manifest(zf, result)

            # 5. Icons
            self._validate_icons(zf, names, result)

        return result

    # -- ZIP ------------------------------------------------------------------

    @staticmethod
    def _validate_zip(pkpass_bytes: bytes, result: ValidationResult) -> bool:
        if not zipfile.is_zipfile(io.BytesIO(pkpass_bytes)):
            result.add_error("File is not a valid ZIP archive.")
            return False
        return True

    # -- Required files -------------------------------------------------------

    @staticmethod
    def _validate_required_files(names: List[str], result: ValidationResult) -> None:
        if "pass.json" not in names:
            result.add_error("Missing required file: pass.json")
        if "manifest.json" not in names:
            result.add_error("Missing required file: manifest.json")
        icon_names = {"icon.png", "icon@2x.png", "icon@3x.png"}
        if not icon_names.intersection(names):
            result.add_error("Missing icon file: at least one of icon.png, icon@2x.png, icon@3x.png required")

    # -- pass.json ------------------------------------------------------------

    def _validate_pass_json(self, zf: zipfile.ZipFile, result: ValidationResult) -> None:
        raw = zf.read("pass.json")
        try:
            pj = json.loads(raw)
        except json.JSONDecodeError as exc:
            result.add_error(f"pass.json is not valid JSON: {exc}")
            return

        result.pass_json = pj

        # formatVersion
        if pj.get("formatVersion") != 1:
            result.add_error(
                f"formatVersion must be integer 1, got {pj.get('formatVersion')!r}"
            )

        # passTypeIdentifier
        pti = pj.get("passTypeIdentifier", "")
        if not isinstance(pti, str) or not pti.startswith("pass."):
            result.add_error(
                f"passTypeIdentifier must start with 'pass.', got {pti!r}"
            )

        # serialNumber
        sn = pj.get("serialNumber", "")
        if not isinstance(sn, str) or not sn:
            result.add_error("serialNumber must be a non-empty string")

        # teamIdentifier
        ti = pj.get("teamIdentifier", "")
        if not isinstance(ti, str) or not ti:
            result.add_error("teamIdentifier must be a non-empty string")

        # organizationName
        org = pj.get("organizationName", "")
        if not isinstance(org, str) or not org:
            result.add_error("organizationName must be a non-empty string")

        # description
        desc = pj.get("description", "")
        if not isinstance(desc, str) or not desc:
            result.add_error("description must be a non-empty string")

        # Exactly one pass type key
        found_types = VALID_PASS_TYPE_KEYS.intersection(pj.keys())
        if len(found_types) != 1:
            result.add_error(
                f"Exactly one pass type key required from {VALID_PASS_TYPE_KEYS}, "
                f"found {found_types or 'none'}"
            )

        # Colors
        for color_key in ("foregroundColor", "backgroundColor", "labelColor"):
            val = pj.get(color_key)
            if val is not None and not RGB_PATTERN.match(val):
                result.add_error(
                    f"{color_key} has invalid rgb format: {val!r}"
                )

        # Barcodes
        self._validate_barcodes(pj, result)

    @staticmethod
    def _validate_barcodes(pj: dict, result: ValidationResult) -> None:
        for field_name in ("barcode", "barcodes"):
            value = pj.get(field_name)
            if value is None:
                continue
            items = value if isinstance(value, list) else [value]
            for idx, bc in enumerate(items):
                prefix = f"{field_name}[{idx}]" if isinstance(value, list) else field_name
                fmt = bc.get("format")
                if fmt not in VALID_BARCODE_FORMATS:
                    result.add_error(
                        f"{prefix}.format is invalid: {fmt!r}. "
                        f"Must be one of {VALID_BARCODE_FORMATS}"
                    )
                if not bc.get("message"):
                    result.add_error(f"{prefix}.message is missing or empty")
                if not bc.get("messageEncoding"):
                    result.add_error(f"{prefix}.messageEncoding is missing or empty")

    # -- manifest.json --------------------------------------------------------

    @staticmethod
    def _validate_manifest(zf: zipfile.ZipFile, result: ValidationResult) -> None:
        raw = zf.read("manifest.json")
        try:
            manifest = json.loads(raw)
        except json.JSONDecodeError as exc:
            result.add_error(f"manifest.json is not valid JSON: {exc}")
            return

        names_in_zip = set(zf.namelist()) - {"manifest.json", "signature"}

        # Every manifest entry must exist in the ZIP with matching hash
        for filename, expected_hash in manifest.items():
            if filename not in names_in_zip:
                result.add_error(
                    f"manifest.json references '{filename}' which is not in the ZIP"
                )
                continue
            actual_hash = hashlib.sha1(zf.read(filename)).hexdigest()
            if actual_hash != expected_hash:
                result.add_error(
                    f"Hash mismatch for '{filename}': "
                    f"manifest says {expected_hash}, actual is {actual_hash}"
                )

        # Every file in ZIP (except manifest/signature) must appear in manifest
        for name in names_in_zip:
            if name not in manifest:
                result.add_error(
                    f"File '{name}' is in the ZIP but missing from manifest.json"
                )

    # -- Icons ----------------------------------------------------------------

    @staticmethod
    def _validate_icons(zf: zipfile.ZipFile, names: List[str], result: ValidationResult) -> None:
        icon_names = [n for n in names if n.startswith("icon") and n.endswith(".png")]
        for icon_name in icon_names:
            data = zf.read(icon_name)
            if not data.startswith(PNG_MAGIC):
                result.add_error(
                    f"{icon_name} does not start with PNG magic bytes"
                )

    # -- iOS 26 ---------------------------------------------------------------

    @staticmethod
    def check_no_ios26_keys(pj: dict) -> List[str]:
        """Return list of iOS 26-only keys found in pass.json."""
        return [k for k in IOS26_KEYS if k in pj]


# ---------------------------------------------------------------------------
# Shared validator instance
# ---------------------------------------------------------------------------

validator = PkpassValidator()


# ---------------------------------------------------------------------------
# Pytest fixtures
# ---------------------------------------------------------------------------

@pytest.fixture(params=TEST_PDFS, scope="module")
def generated_passes(request):
    """Generate .pkpass files from a test PDF using PassGenerator directly.

    Returns (filename, list_of_pkpass_bytes, warnings).
    """
    filename = request.param
    pdf_path = os.path.join(TEST_FILES_DIR, filename)
    if not os.path.exists(pdf_path):
        pytest.skip(f"Test PDF not found: {pdf_path}")

    with open(pdf_path, "rb") as f:
        pdf_data = f.read()

    os.environ["API_KEY"] = "development-api-key"

    from app.services.pass_generator import PassGenerator

    generator = PassGenerator()
    pkpass_files, _barcodes, _ticket_info, warnings = generator.create_pass_from_pdf_data(
        pdf_data, filename, None
    )

    return filename, pkpass_files, warnings


# ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------

class TestPkpassValidation:

    def test_generates_at_least_one_pass(self, generated_passes):
        filename, pkpass_files, _warnings = generated_passes
        assert len(pkpass_files) >= 1, (
            f"[{filename}] Expected at least one .pkpass file, got {len(pkpass_files)}"
        )

    def test_pkpass_is_valid_zip(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        for idx, pkpass_bytes in enumerate(pkpass_files):
            assert zipfile.is_zipfile(io.BytesIO(pkpass_bytes)), (
                f"[{filename}] Pass #{idx+1} is not a valid ZIP file"
            )

    def test_pkpass_contains_required_files(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        for idx, pkpass_bytes in enumerate(pkpass_files):
            with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
                names = zf.namelist()
                assert "pass.json" in names, (
                    f"[{filename}] Pass #{idx+1} missing pass.json"
                )
                assert "manifest.json" in names, (
                    f"[{filename}] Pass #{idx+1} missing manifest.json"
                )
                icon_names = {"icon.png", "icon@2x.png", "icon@3x.png"}
                assert icon_names.intersection(names), (
                    f"[{filename}] Pass #{idx+1} missing all icon files. Files: {names}"
                )

    def test_pass_json_required_fields(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        required = [
            "formatVersion", "passTypeIdentifier", "serialNumber",
            "teamIdentifier", "organizationName", "description",
        ]
        for idx, pkpass_bytes in enumerate(pkpass_files):
            with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
                pj = json.loads(zf.read("pass.json"))
                for key in required:
                    assert key in pj, (
                        f"[{filename}] Pass #{idx+1} pass.json missing required field '{key}'"
                    )
                    val = pj[key]
                    if isinstance(val, str):
                        assert val, (
                            f"[{filename}] Pass #{idx+1} pass.json field '{key}' is empty string"
                        )

    def test_format_version_is_integer_one(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        for idx, pkpass_bytes in enumerate(pkpass_files):
            with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
                pj = json.loads(zf.read("pass.json"))
                fv = pj.get("formatVersion")
                assert fv == 1 and isinstance(fv, int), (
                    f"[{filename}] Pass #{idx+1} formatVersion must be integer 1, got {fv!r} ({type(fv).__name__})"
                )

    def test_exactly_one_pass_type_key(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        for idx, pkpass_bytes in enumerate(pkpass_files):
            with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
                pj = json.loads(zf.read("pass.json"))
                found = VALID_PASS_TYPE_KEYS.intersection(pj.keys())
                assert len(found) == 1, (
                    f"[{filename}] Pass #{idx+1} must have exactly one pass type key "
                    f"from {VALID_PASS_TYPE_KEYS}, found {found or 'none'}"
                )

    def test_colors_are_valid_rgb(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        for idx, pkpass_bytes in enumerate(pkpass_files):
            with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
                pj = json.loads(zf.read("pass.json"))
                for color_key in ("foregroundColor", "backgroundColor", "labelColor"):
                    val = pj.get(color_key)
                    if val is not None:
                        assert RGB_PATTERN.match(val), (
                            f"[{filename}] Pass #{idx+1} {color_key} has invalid rgb format: {val!r}"
                        )

    def test_manifest_hashes_match(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        for idx, pkpass_bytes in enumerate(pkpass_files):
            with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
                manifest = json.loads(zf.read("manifest.json"))
                names_in_zip = set(zf.namelist()) - {"manifest.json", "signature"}

                for mf_name, expected_hash in manifest.items():
                    assert mf_name in names_in_zip, (
                        f"[{filename}] Pass #{idx+1} manifest references '{mf_name}' not in ZIP"
                    )
                    actual_hash = hashlib.sha1(zf.read(mf_name)).hexdigest()
                    assert actual_hash == expected_hash, (
                        f"[{filename}] Pass #{idx+1} hash mismatch for '{mf_name}': "
                        f"manifest={expected_hash}, actual={actual_hash}"
                    )

                for name in names_in_zip:
                    assert name in manifest, (
                        f"[{filename}] Pass #{idx+1} file '{name}' in ZIP but missing from manifest"
                    )

    def test_icon_files_are_valid_png(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        for idx, pkpass_bytes in enumerate(pkpass_files):
            with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
                icon_names = [n for n in zf.namelist() if n.startswith("icon") and n.endswith(".png")]
                assert icon_names, (
                    f"[{filename}] Pass #{idx+1} has no icon PNG files"
                )
                for icon_name in icon_names:
                    data = zf.read(icon_name)
                    assert data.startswith(PNG_MAGIC), (
                        f"[{filename}] Pass #{idx+1} {icon_name} is not a valid PNG"
                    )

    def test_barcode_format_is_valid(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        for idx, pkpass_bytes in enumerate(pkpass_files):
            with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
                pj = json.loads(zf.read("pass.json"))
                for field_name in ("barcode", "barcodes"):
                    value = pj.get(field_name)
                    if value is None:
                        continue
                    items = value if isinstance(value, list) else [value]
                    for bc_idx, bc in enumerate(items):
                        fmt = bc.get("format")
                        assert fmt in VALID_BARCODE_FORMATS, (
                            f"[{filename}] Pass #{idx+1} {field_name}[{bc_idx}].format "
                            f"is invalid: {fmt!r}"
                        )
                        assert bc.get("message"), (
                            f"[{filename}] Pass #{idx+1} {field_name}[{bc_idx}].message "
                            f"is missing or empty"
                        )
                        assert bc.get("messageEncoding"), (
                            f"[{filename}] Pass #{idx+1} {field_name}[{bc_idx}].messageEncoding "
                            f"is missing or empty"
                        )

    def test_no_ios26_keys_when_disabled(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        # Unless ENABLE_IOS26_FEATURES is set, these keys must not appear
        ios26_enabled = os.getenv("ENABLE_IOS26_FEATURES", "false").lower() == "true"
        if ios26_enabled:
            pytest.skip("iOS 26 features are enabled, skipping negative test")
        for idx, pkpass_bytes in enumerate(pkpass_files):
            with zipfile.ZipFile(io.BytesIO(pkpass_bytes)) as zf:
                pj = json.loads(zf.read("pass.json"))
                found_ios26 = validator.check_no_ios26_keys(pj)
                assert not found_ios26, (
                    f"[{filename}] Pass #{idx+1} contains iOS 26 keys "
                    f"{found_ios26} but ENABLE_IOS26_FEATURES is not set"
                )

    def test_full_validation_passes(self, generated_passes):
        filename, pkpass_files, _ = generated_passes
        for idx, pkpass_bytes in enumerate(pkpass_files):
            result = validator.validate(pkpass_bytes)
            assert result.is_valid, (
                f"[{filename}] Pass #{idx+1} full validation failed with errors:\n"
                + "\n".join(f"  - {e}" for e in result.errors)
            )


# ---------------------------------------------------------------------------
# Standalone CLI mode
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python test_pkpass_validation.py <file.pkpass> [...]")
        sys.exit(1)

    v = PkpassValidator()
    exit_code = 0

    for path in sys.argv[1:]:
        print(f"\n{'=' * 60}")
        print(f"Validating: {path}")
        print("=" * 60)

        if not os.path.isfile(path):
            print(f"  ERROR: File not found: {path}")
            exit_code = 1
            continue

        with open(path, "rb") as f:
            data = f.read()

        result = v.validate(data)

        if result.errors:
            for err in result.errors:
                print(f"  ERROR: {err}")
            exit_code = 1
        if result.warnings:
            for warn in result.warnings:
                print(f"  WARN:  {warn}")
        if result.is_valid:
            print("  PASSED")

            # Print summary info from pass.json
            if result.pass_json:
                pj = result.pass_json
                print(f"    formatVersion: {pj.get('formatVersion')}")
                print(f"    passTypeIdentifier: {pj.get('passTypeIdentifier')}")
                print(f"    description: {pj.get('description', '')[:80]}")
                ptk = VALID_PASS_TYPE_KEYS.intersection(pj.keys())
                print(f"    passType: {ptk}")
                has_barcode = bool(pj.get("barcode") or pj.get("barcodes"))
                print(f"    hasBarcode: {has_barcode}")

    sys.exit(exit_code)
